% identify_step.m
% Identificación de modelos de segundo orden (alejamiento y acercamiento)
% Incluye diagramas de polos y ceros
clc; clear; close all;

% --- (Octave) cargar paquetes si corresponde ---
if exist('pkg','file')
  try  control; catch; end
  try  optim;   catch; end
end

% --- parámetros usuario ---
csvfile = 'datos_puerta.csv';
time_in_ms = true;
tail_samples = 50;

% --- carga datos ---
data = csvread(csvfile, 1, 0);
t_raw = data(:,1);
if time_in_ms
  t_raw = t_raw / 1000;
end
u_raw = data(:,2);
y_raw = data(:,3);

% --- Suavizado para detecciones ---
y_smooth = y_raw;
if length(y_raw) > 5
  y_smooth = filter(ones(1,5)/5, 1, y_raw);
end

[max_dist, idx_max] = max(y_smooth);
fprintf('\n[DEBUG] Distancia máxima: %.2f cm en índice %d (t=%.2fs)\n', max_dist, idx_max, t_raw(idx_max));

idx_start = find(u_raw > 50, 1, 'first');
fprintf('[DEBUG] Primer PWM>50 en índice %d (t=%.2fs)\n', idx_start, t_raw(idx_start));

% ------------------------------
% SEGMENTO 1: ALEJAMIENTO
% ------------------------------
idx_end_alej = idx_max + 30;
if idx_end_alej > length(t_raw)
  idx_end_alej = length(t_raw);
end

if y_raw(idx_end_alej) > y_raw(idx_start)
  t_alej = t_raw(idx_start:idx_end_alej);
  u_alej = u_raw(idx_start:idx_end_alej);
  y_alej = y_raw(idx_start:idx_end_alej);
  t_alej = t_alej - t_alej(1);
  fprintf('[DEBUG] Alejamiento: índices %d-%d, y: %.2f->%.2f cm\n', ...
         idx_start, idx_end_alej, y_raw(idx_start), y_raw(idx_end_alej));
else
  error('No se detectó alejamiento válido');
end

% ------------------------------
% SEGMENTO 2: ACERCAMIENTO
% ------------------------------
idx_start_acer = idx_max;
threshold_drop = 1.0;
for i = (idx_max+1):(length(y_raw)-10)
  future_samples = y_raw(i:min(i+10, length(y_raw)));
  if (y_raw(i) < y_raw(idx_max) - threshold_drop) && (mean(diff(future_samples)) < -0.1)
    idx_start_acer = i;
    break;
  end
end

fprintf('[DEBUG] Acercamiento detectado en índice %d (t=%.2fs, y=%.2f cm)\n', ...
       idx_start_acer, t_raw(idx_start_acer), y_raw(idx_start_acer));

t_acer = t_raw(idx_start_acer:end);
u_acer = u_raw(idx_start_acer:end);
y_acer = y_raw(idx_start_acer:end);

if y_acer(end) < y_acer(1) - 5
  t_acer = t_acer - t_acer(1);
  fprintf('[DEBUG] Acercamiento válido: y: %.2f->%.2f cm (cambio: %.2f cm)\n', ...
         y_acer(1), y_acer(end), y_acer(1)-y_acer(end));
else
  error('No se detectó acercamiento válido');
end

% ========================================================================
% IDENTIFICAR AMBOS MOVIMIENTOS 
% ========================================================================
[K_alej, wn_alej, zeta_alej, G_alej, Fs_alej, fit_alej] = ...
  identificar_segundo_orden(t_alej, u_alej, y_alej, 'ALEJAMIENTO');

[K_acer, wn_acer, zeta_acer, G_acer, Fs_acer, fit_acer] = ...
  identificar_segundo_orden(t_acer, u_acer, y_acer, 'ACERCAMIENTO');

% Comparación y promedio
fprintf('\n=== COMPARACIÓN ===\n');
fprintf('                Alejamiento    Acercamiento\n');
fprintf('K (cm/PWM):     %-12.6g   %-12.6g\n', K_alej, K_acer);
fprintf('wn (rad/s):     %-12.4g   %-12.4g\n', wn_alej, wn_acer);
fprintf('zeta:           %-12.4g   %-12.4g\n', zeta_alej, zeta_acer);

K_avg = (K_alej + K_acer)/2;
wn_avg = (wn_alej + wn_acer)/2;
zeta_avg = (zeta_alej + zeta_acer)/2;
num_avg = K_avg * wn_avg^2;
den_avg = [1, 2*zeta_avg*wn_avg, wn_avg^2];
G_avg = tf(num_avg, den_avg);

try
  polos_avg = pole(G_avg);
  ceros_avg = zero(G_avg);
catch
  [numv, denv] = tfdata(G_avg, 'v');
  % si el numerador es escalar (sin ceros finitos), roots devuelve vacío o vacío num
  if all(numv == 0)
    ceros_avg = [];
  else
    ceros_avg = roots(numv);
  end
  polos_avg = roots(denv);
end

fprintf('\n=== MODELO PROMEDIO ===\n');
fprintf('K = %.6g cm/PWM\n', K_avg);
fprintf('wn = %.4g rad/s\n', wn_avg);
fprintf('zeta = %.4g\n', zeta_avg);
fprintf('G(s) = %.6g / (s^2 + %.4g*s + %.4g)\n', num_avg, den_avg(2), den_avg(3));

% Mostrar polos
if isempty(polos_avg)
  fprintf('Polos: (ninguno)\n');
else
  fprintf('\nPolos promedio (%d):\n', length(polos_avg));
  for k = 1:length(polos_avg)
    p = polos_avg(k);
    fprintf('  p%d = %+.6f %+.6fj\n', k, real(p), imag(p));
  end
end

% Mostrar ceros
if isempty(ceros_avg)
  fprintf('Ceros: (ninguno)\n');
else
  fprintf('\nCeros promedio (%d):\n', length(ceros_avg));
  for k = 1:length(ceros_avg)
    z = ceros_avg(k);
    fprintf('  z%d = %+.6f %+.6fj\n', k, real(z), imag(z));
  end
end

% ========================================================================
% GRAFICAS
% ========================================================================

% Figura 1: respuesta al escalón del modelo promedio
figure('Name','Step Response modelo promedio','NumberTitle','off');
step(G_avg * 255);
title('Step response - modelo promedio (entrada PWM=255)');
grid on;

% Figura 2: mapas polos y ceros
figure('Name','Polos y Ceros','NumberTitle','off','Position',[200 200 1000 400]);

subplot(1,3,1);
try
  pzmap(G_alej);
catch
  % si pzmap no está disponible, usar pole() y zero() para graficar
  polos = pole(G_alej); ceros = zero(G_alej);
  plot(real(polos), imag(polos), 'x','MarkerSize',10,'LineWidth',2); hold on;
  plot(real(ceros), imag(ceros), 'o','MarkerSize',8,'LineWidth',1.5);
  xlabel('Re'); ylabel('Im'); title('Polos/Ceros - Alejamiento'); grid on; axis equal;
end
title('Polos y Ceros - Alejamiento');

subplot(1,3,2);
try
  pzmap(G_acer);
catch
  polos = pole(G_acer); ceros = zero(G_acer);
  plot(real(polos), imag(polos), 'x','MarkerSize',10,'LineWidth',2); hold on;
  plot(real(ceros), imag(ceros), 'o','MarkerSize',8,'LineWidth',1.5);
  xlabel('Re'); ylabel('Im'); title('Polos/Ceros - Acercamiento'); grid on; axis equal;
end
title('Polos y Ceros - Acercamiento');

subplot(1,3,3);
try
  pzmap(G_avg);
catch
  polos = pole(G_avg); ceros = zero(G_avg);
  plot(real(polos), imag(polos), 'x','MarkerSize',10,'LineWidth',2); hold on;
  plot(real(ceros), imag(ceros), 'o','MarkerSize',8,'LineWidth',1.5);
  xlabel('Re'); ylabel('Im'); title('Polos/Ceros - Promedio'); grid on; axis equal;
end
title('Polos y Ceros - Promedio');

fprintf('\n=== ANÁLISIS COMPLETADO ===\n');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FUNCIONES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function err = calcular_error_modelo(p, y_real, t, u_amp, dir)
  % p = [K, wn, zeta], y_real = y_rel (sin baseline), dir = +1 o -1
  K = p(1); wn = p(2); zeta = p(3);
  if zeta < 1
    wd = wn * sqrt(1 - zeta^2);
    phi = atan2(sqrt(1 - zeta^2), zeta);
    y_pred = dir * K * u_amp .* (1 - exp(-zeta*wn.*t)./sqrt(1 - zeta^2) .* ...
             sin(wd.*t + phi));
  else
    s1 = wn*(zeta + sqrt(zeta^2 - 1));
    s2 = wn*(zeta - sqrt(zeta^2 - 1));
    A = (s1/(s1 - s2)); B = (-s2/(s1 - s2));
    y_pred = dir * K * u_amp .* (1 - A*exp(-s1.*t) - B*exp(-s2.*t));
  end
  err = sum((y_real - y_pred).^2);
end

function [K, wn, zeta, G, Fs, fit_data] = identificar_segundo_orden(t, u, y, nombre)
  N = length(t);
  dt = mean(diff(t)); Fs = 1/dt;
  tail = min(50, N);
  y_final = mean(y(N-tail+1:N));
  y_init  = mean(y(1:min(tail,N)));
  delta_y = y_final - y_init;        % con signo
  dir = sign(delta_y);
  delta_mag = abs(delta_y);
  if delta_mag < 1.0, error('Movimiento insignificante en %s', nombre); end

  u_final = mean(u(N-tail+1:N));
  u_init  = mean(u(1:min(tail,N)));
  if abs(u_final - u_init) < 1
    step_amp = mean(u);
    fprintf('  [INFO] PWM constante: %.1f\n', step_amp);
  else
    step_amp = u_final - u_init;
  end

  dy = diff(y);
  idx_step = find(abs(dy) > 0.5, 1, 'first');
  if isempty(idx_step), idx_step = 1; end
  t0 = t(idx_step);
  t_rel = t - t0;
  idx_after = find(t_rel >= 0);
  t_fit = t_rel(idx_after);
  y0 = mean(y(1:min(10, idx_step)));
  y_rel = y(idx_after) - y0;   % con signo (positivo si aumenta)

  K_est = delta_mag / max(abs(step_amp),1e-6);

  % Estimar zeta desde overshoot si existe
  [y_peak, idx_peak_rel] = max((y_rel) .* dir); % busca en la dirección del movimiento
  if ~isempty(idx_peak_rel) && y_peak > delta_mag * 1.01
    overshoot = (y_peak - delta_mag) / delta_mag;
    zeta0 = abs(log(overshoot)) / sqrt(pi^2 + log(overshoot)^2);
    zeta0 = max(0.05, min(0.99, zeta0));
  else
    zeta0 = 0.7;
  end

  ts_est = max(0.1, t_fit(end)*0.8);
  wn0 = 4 / (zeta0 * ts_est);
  if wn0 <= 0 || wn0 > 100, wn0 = 2.0; end

  p0 = [K_est, wn0, zeta0];
  lb = [0.001, 0.01, 0.01];
  ub = [10, 200, 5];

  model_err = @(p) calcular_error_modelo(p, y_rel, t_fit, abs(step_amp), dir);

  options = optimset('Display','off', 'MaxIter', 2000, 'TolX', 1e-8);
  try
    popt = fmincon(model_err, p0, [],[],[],[], lb, ub, [], options);
  catch
    penalized_err = @(p) model_err(p) + 1e8*(any(p<lb) | any(p>ub));
    popt = fminsearch(penalized_err, p0, options);
  end

  K = popt(1); wn = popt(2); zeta = popt(3);

  num = K * wn^2;
  den = [1, 2*zeta*wn, wn^2];
  G = tf(num, den);

  % preparar fit_data para graficas (y_model y_real con baseline)
  if zeta < 1
    wd = wn*sqrt(1-zeta^2);
    phi = atan2(sqrt(1-zeta^2), zeta);
    y_model = dir * K * abs(step_amp) .* (1 - exp(-zeta*wn.*t_fit)./sqrt(1-zeta^2) .* sin(wd.*t_fit + phi));
  else
    s1 = wn*(zeta + sqrt(zeta^2 - 1));
    s2 = wn*(zeta - sqrt(zeta^2 - 1));
    A = (s1/(s1 - s2)); B = (-s2/(s1 - s2));
    y_model = dir * K * abs(step_amp) .* (1 - A*exp(-s1.*t_fit) - B*exp(-s2.*t_fit));
  end

  fit_data.t = t_fit;
  fit_data.y_real = y_rel;
  fit_data.y_model = y_model;
  fit_data.y0 = y0;

  % Mostrar resultados resumidos
  fprintf('\n=== %s - SEGUNDO ORDEN ===\n', nombre);
  fprintf('Samples: %d | Dur: %.2fs | Fs: %.2f Hz\n', N, t(end)-t(1), Fs);
  fprintf('K=%.6g cm/PWM | wn=%.4g rad/s | zeta=%.4g\n', K, wn, zeta);

end

